#pragma once

#include "Result.h"
#include "SQLException.h"
#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>
#include <string>
#include <tuple>
#include <cstring>

/**
 * This class establishes a connection (session) to a specific database.
 * SQL statements  are executed and results are returned within the context of a
 * connection.
 */
class Connection
{
public:
    /**
     * Creates a new Connection object which actually does not represent a session.
     */
    Connection() = default;

    /**
     * Attempts to establish a connection to the given database URL.
     *
     * @param  url           A database url of the form
     *                           DRIVER=protocol;SERVER=hostname;DATABASE=database
     * @param  user          The database user on whose behalf the connection is
     *                       being made
     * @param  passwd        The users password
     *
     * @throws SQLException  If a database access error occurs
     */
    Connection(const std::string& url, const std::string& user, const std::string& passwd);

    Connection(const Connection&) = delete;

    /**
     * Move constructor
     */
    Connection(Connection&& x);

    /**
     * Destructor
     */
    ~Connection();

    Connection& operator=(const Connection&) = delete;

    /**
     * Move assignment
     */
    Connection& operator=(Connection&& x);

    /**
     * Initiates a transaction.
     *
     * @throws SQLException  If a database access error occurs
     */
    void begin();

    /**
     * Executes  the SQL query  and returns  the Result object  generated by the
     * query.
     *
     * @param  sql           A SQL statement  that may contain  one or more  '?'
     *                       parameter placeholders
     * @param  params        The objects containing the input parameter values
     *
     * @return A Result object that contains the data produced by the query
     *
     * @throws SQLException  If a database access error occurs
     */
    template <class... Params> Result executeQuery(const std::string& sql, Params&&... params);

    /**
     * Execute an SQL statement and returns the number of affected rows.
     *
     * @param  sql           A SQL statement  that may contain  one or more  '?'
     *                       parameter placeholders
     * @param  params        The objects containing the input parameter values
     *
     * @return Returns the number of rows  that were modified  or deleted by the
     *         SQL statement.
     *
     * @throws SQLException  If a database access error occurs
     */
    template <class... Params> size_t executeUpdate(const std::string& sql, Params&&... params);

    /**
     * Commits a transaction
     *
     * @throws SQLException  If a database access error occurs
     */
    void commit();

    /**
     * Rolls back a transaction
     *
     * @throws SQLException  If a database access error occurs
     */
    void rollback();

    /**
     * Closes the Connection and releases its resources.
     *
     * It is strongly recommended  to explicitly commit  or roll back  an active
     * transaction prior to calling the close method.
     */
    void close();

private:
    void setAutoCommit(bool val);
    template <class... Params> void bind(SQLHSTMT stmt, size_t i, int64_t first, Params&&... params);
    void bind(SQLHSTMT stmt, size_t i);

    static const SQLHSTMT INVALID_ENV_HANDLE;
    static const SQLHDBC  INVALID_DBC_HANDLE;

    SQLHENV env = INVALID_ENV_HANDLE;
    SQLHDBC dbc = INVALID_DBC_HANDLE;
};

template <class... Params>
inline Result Connection::executeQuery(const std::string& sql, Params&&... params)
{
    SQLHSTMT stmt = {};
    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);
    if (!SQL_SUCCEEDED(ret))
    {
        throw SQLException(__FILE__ + (": " + std::to_string(__LINE__)));
    }

    std::basic_string<SQLCHAR> sqlchar(sql.begin(), sql.end());
    ret = SQLPrepareA(stmt, sqlchar.data(), sqlchar.length());
    if (!SQL_SUCCEEDED(ret))
    {
        throw SQLException(__FILE__ + (": " + std::to_string(__LINE__)));
    }
    bind(stmt, 1, std::forward<Params>(params)...);

    ret = SQLExecute(stmt);
    if (!SQL_SUCCEEDED(ret))
    {
        throw SQLException(__FILE__ + (": " + std::to_string(__LINE__)));
    }

    return Result(stmt);
}

template <class... Params>
inline size_t Connection::executeUpdate(const std::string& sql, Params&&... params)
{
    //TODO
    return {};
}

template <class... Params>
inline void Connection::bind(SQLHSTMT stmt, size_t i, int64_t first, Params&&... params)
{
    SQLLEN sz = sizeof(first);
    SQLRETURN ret = SQLBindParam(
            stmt,
            i,
            SQL_PARAM_INPUT,
            SQL_C_LONG,
            0,
            0,
            &first,
            &sz);
    if (!SQL_SUCCEEDED(ret))
    {
        throw SQLException(__FILE__ + (": " + std::to_string(__LINE__)));
    }
    bind(stmt, i + 1, std::forward<Params>(params)...);
}
